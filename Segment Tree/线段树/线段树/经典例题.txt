一：区间最小值
基础，略。

二：区间和问题
1.修改单个数：基础，需要注意的是a[i,j]=f[j]-f[i-1]，f[j]=1～J的和。
2.修改某区间，则将区间分割，使得线段树上的一些区间完全覆盖要修改的区间，回答时根据经过的区间来调整答案。

三：区间覆盖问题
一般就是使某些区间染成颜色，然后询问某些点的颜色情况。
记录每一次操作的编号。
将区间染色时候将区间分割，使得线段树上的一些区间完全覆盖要修改的区间，回答时，根据经过的区间，找出编号最大的修改即可(这种方法与第八种方法类似)。

四：询问某区间不同XX情况
以染色情况为例：

题目描述：
给一个30000个元素的序列A,
然后100000个操作,
每个操作,可能是改变一个元素值
或者一个询问Q(a,b),表示A[a..b]中有多少个不同的元素.
例如对{1,2,2,1,4} 询问Q(1,4),答案是2.


题解：
用pre[ i ]表示j, j < i,且J最大， a[j] = a[ i ]。
那么询问[a,b]等价于询问[a,b]里面多少个pre[ i ]小于a，这个可以用线段树维护（可以在线段树里套平衡树来存当前区间的pri)
至于修改一个数 显然最多只会有两个pre[ i ]改变，则：
1.用一个平衡树找出新的颜色，再套一个平衡树，从中找出比i小且最大的那个数，假设这个数的位置为J，则pri=j,再找出比I大且最小的树k,pri[k]=i。
2.维护线段树

当然颜色数小可以用状态压缩

五：区间最大连续数和
线段树每个区间中，存：
1.这个区间和
2.包含最左边元素的最大子序列和
3.包含最右边元素的最大子序列和
4.区间最大子序列和

六：
优化方程f[i]=min(f[j]+cost[i,j]);{i<j<=k)

原方程：f[i]=min(cost[i,j]+f[j])
改进为：f[i]=cost[i,n]-cost[j,n]+f[j]=cost[i,n]-min(cost[j,n]-f[j]);
即：加量=总量-点量（一定）。
运用改进后的式子，决策时候用线段树取最小值，时间复杂度优化为O(nlogn)，若K=n则可以优化为O(n）

拓展：
优化方程f[i]=min(f[j]+(cost[i,j]-t)^2);
原方程：f[i]=min((cost[i,j]-t)^2+f[j])
改进为：f[i]=min((cost[i,n]-cost[j,n]-t)^2+f[j])=(cost[i,n])^2-2*cost[i,n]+1-2*cost[i,n]*t+t^2+min(2*cost[j,n]*t+f[j]);
即：f[i]=min(d[j])+(cost[i,n])^2-2*cost[i,n]+1-2*cost[i,n]*t+t^2;
    d[i]=2*cost[i,n]*t+f[i];

七:
修改某段区间,询问某段区间的情况.

将修改区间分割成线段树上的几个小区间,然后标记(表示子树都是这个颜色),然后标记完回家的时候顺便更新祖先上的信息(要将祖先上的标记取消).此时,某一个点的颜色情况就是从[i,i]到[1,n]的路径上最上面的那个标记([i,i]也做一个标记).

要注意的是,当我们再次修改某个标记下方的节点时候,要将标记下代,即[l,r]要下代到他的后代(这样才能保证没有被修改的后代区间颜色不变).

八:
增加某段区间的值,询问某段区间的和(最大值)
这种时候有比第七种更简单的方法,直接将值分割到各个区间,则和等于[i,i]到[1,n]路径上各个区间的和(最大值).